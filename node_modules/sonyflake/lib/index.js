'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const Epoch = {
    UNIX: 0,
    TWITTER: 1288834974657,
    DISCORD: 1420070400000,
};
const DEFAULT_VALUE = 0;
const DEFAULT_SEQUENCE = DEFAULT_VALUE;
const USIGNED_INCREASE = 1n;
const SIGNED_INCREASE = -1n;
const MACHINE_ID_BITS = 16n;
const SEQUENCE_BITS = 8n;
const MACHINE_ID_MASK = SIGNED_INCREASE ^ (SIGNED_INCREASE << MACHINE_ID_BITS);
const SEQUENCE_MASK = SIGNED_INCREASE ^ (SIGNED_INCREASE << SEQUENCE_BITS);
const TIMESTAMP_LEFT_SHIFT = SEQUENCE_BITS + MACHINE_ID_BITS;
const MACHINE_ID_SHIFT = MACHINE_ID_BITS;

const getNowBigInt = () => BigInt(Date.now());

class Sonyflake {
    /**
     * Constructor
     */
    constructor({ epoch = Epoch.UNIX, machineId = DEFAULT_VALUE, } = {}) {
        /**
         * Sequence increment for process
         */
        this.sequence = BigInt(DEFAULT_SEQUENCE);
        /**
         * Latest timestamp
         */
        this.latestTimestamp = getNowBigInt();
        if (epoch > Number(getNowBigInt())) {
            throw new Error('Epoch must be less than current time');
        }
        this.epoch = epoch;
        this.machineId = BigInt(machineId) & MACHINE_ID_MASK;
    }
    /**
     * Generate a Snowflake
     */
    nextId() {
        const timestamp = getNowBigInt();
        if (this.latestTimestamp === timestamp) {
            this.sequence = (this.sequence + USIGNED_INCREASE) & SEQUENCE_MASK;
        }
        else {
            this.sequence = BigInt(DEFAULT_SEQUENCE);
            this.latestTimestamp = timestamp;
        }
        return this.generateCustomId({
            timestamp: Number(timestamp),
            sequence: Number(this.sequence),
        });
    }
    /**
     * Decompose the Snowflake with local epoch
     */
    decompose(snowflake) {
        return Sonyflake.decompose(snowflake, {
            epoch: this.epoch,
        });
    }
    /**
     * Generate a custom Snowflake
     */
    generateCustomId({ timestamp, sequence, }) {
        return (((BigInt(timestamp) - BigInt(this.epoch)) << TIMESTAMP_LEFT_SHIFT) |
            (BigInt(sequence) << MACHINE_ID_SHIFT) |
            this.machineId).toString();
    }
    /**
     * Decompose the Snowflake timestamp
     */
    static decomposeTimestamp(snowflake, epoch) {
        return Number((BigInt(snowflake) >> TIMESTAMP_LEFT_SHIFT) + BigInt(epoch));
    }
    /**
     * Decompose the Snowflake machineId
     */
    static decomposeMachineId(snowflake) {
        return Number(BigInt(snowflake) & MACHINE_ID_MASK);
    }
    /**
     * Decompose the Snowflake sequence
     */
    static decomposeSequence(snowflake) {
        return Number((BigInt(snowflake) >> MACHINE_ID_BITS) & SEQUENCE_MASK);
    }
    /**
     * Decompose the Snowflake
     */
    static decompose(snowflake, { epoch }) {
        return {
            timestamp: Sonyflake.decomposeTimestamp(snowflake, epoch),
            machineId: Sonyflake.decomposeMachineId(snowflake),
            sequence: Sonyflake.decomposeSequence(snowflake),
        };
    }
}

exports.Epoch = Epoch;
exports.Sonyflake = Sonyflake;
exports.default = Sonyflake;
